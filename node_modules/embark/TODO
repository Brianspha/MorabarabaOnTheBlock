
Refactor Next:
V CodeGenerator: remove contractsManager
V---> pass contract object instead of contract name for code generator (does it make sense?)
V---> query list of contracts instead of using object directly
- Deploy:
----> (maybe) arguments replacement could be done in a module
----> refactor plugins actions method
----> define accounts selection in blockchain module
----> move beforeDeploy plugin to new one
----> refactor deploy object creation
----> refactor gas estimation method
----> remove deploy all and make it a request with a callback instead
----> add events and plugins for before and after deploy
- DeployManager: remove/rethink DeployManager
----> first simplify method even more, before looking more into how to remove it
----> make build contracts a request used by the deployer
----> remove compile option
----> make blockchain connection implicit or as an event/before deploy necessary plugin (error stops execution)
----> make determining default account implicit & up to the plugin

idea: cmd line should go into the config, and requested by the modules

TODO:
remove vanilla events

Refactor After:
- CodeGenerator:
----> make the code generation something done by a plugin, and registered by each compoenent or module, code generator should only care about execWhenReady

idea:
- create a set of folders core_modules which contain each of the core modules
- convert each of the core modules to work just like a module
- even the core modules register their own components (e.g registering the abstract code in embark.js)

the web3 object should be abstracted, instead it should be a module that abstracts the 'blockchain'

Blockchain.getAccounts => web3.eth.getAccounts
Blockchain.deployContract => etc...

ideally this is done in a module (web3 or Ethereum) that registers this stuff

TODO:
* add optional cb
V deployTracker working with events
* add ether.js implementation
* lots of web3 related stuff can be moved out (setting default account, checking connection)
* stuff like code generator, deployTracker, etc.. should be completly separate and work with events
* deploy object can be all just deploy method
** unclear how to set the gas (but maybe doesn't matter?)
*** could be another API / module that reacts to a request to evaluate gas costs
* chains.json needs to work again

rename startService to startCoreModule or startComponent


separate:
V Compiler -> module, can compile through a request (contract.js wouldn't need to initialize it)
* CodeGenerator -> can be generalist, with each component (specially web3) registering individually
** only stuff like execWhenReady is specific to the code generator
* Deploy -> RunCode can be a module and talked to with events
* Deploy -> The CodeGenerator and RunCode feel like they don't belong here, perhaps should in some module that reacts to events
--> e.g a module that implements 'afterDeploy' and such
-----> so we will need APIs to run things beforeDeploy , afterDeploy, etc.. and can implement such things
* DeployManager -> overall it's sort of unnecessary since a lot of its functionality can be implemented as events
--> afterDeploy event for doing the afterDeploy
* Contracts
--> there is potential for the contracts config to be done through plugins, it applies to afterDeploy / onDeploy
* RunCode
--> for the web3 object, can simply detect changes to it
--> better yet is having RunCode with an api to register objects

better plugin:
- consider a more generalistic plugin, to register calls, in which the dev can specify the "event" he wants to lock on too
- plugin side: this.plugins.registerActionForEvent("contracts:afterDeploy", cb)
- core side: this.plugins.runActionsForEvent("contracts:afterDeploy", cb)

--> could also have options like 
- plugin side: this.plugins.registerActionForEvent("contracts:afterDeploy", {after: "pluginName"}, cb)

traces:
* add traces everywhere
* a good use case is async debug responding to the EMBARK_DEBUG flag

Add "requiredModules"
* modules that need to be open / running for the module to function
--> not the same as 'optional'


// TODO: add other params
//this.currentChain.networkId = "";
//this.currentChain.networkType = "custom"


// TODO:
//* create an event on code_generator to get the js of a contract by name
//* get the contract JSON through an API instead of a file
//* write the contract JSON separatetly


Action:
1. Initialize Embark Engine
2. Start *relevant* Services
3. Specify any events if might want to react to (optional)
4. Trigger an event

Module:
1. Registers in the plugin API
2. Reacts to and Emits events
3. Has no connection to outside files

Two "types" of modules:
1. "Core" type - e.g Compiler
2. "Module" or "Plugin" - e.g Solidity

